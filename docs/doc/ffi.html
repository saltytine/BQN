<head>
  <meta charset="utf-8">
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>BQN: Foreign Function Interface (FFI)</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">doc</a></div>
<h1 id="foreign-function-interface-ffi"><a class="header" href="#foreign-function-interface-ffi">Foreign Function Interface (FFI)</a></h1>
<p>BQN's <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">foreign function interface</a> allows it to interface with libraries written in C, or other languages that support a compatible format. It's invoked with <code><span class='Function'>‚Ä¢FFI</span></code>, which performs the necessary lookups and conversions to call a function from a dynamic shared library (extension .so in Linux, .dylib in macOS, and .dll in Windows). This function is <a href="../spec/system.html#foreign-function-interface-ffi">specified</a> by BQN and <a href="https://github.com/dzaima/CBQN/blob/master/docs/system.md#ffi">implemented</a> by CBQN‚Äîwithout support for all possible types, but enough to cover practical use well.</p>
<p>Warning: object code is unsafe by nature. The OS will hopefully prevent it from exceeding the privileges of the BQN interpreter, but anything code in the interpreter could do is fair game. It might crash, write files, corrupt BQN arrays resulting in &quot;impossible&quot; behavior later on, or read everything in your home directory and email it to someone. Be careful when invoking the FFI!</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<p><code><span class='Function'>‚Ä¢FFI</span></code> takes the path of the object file as <code><span class='Value'>ùï®</span></code>, with local paths resolved relative to the source file as in <code><span class='Function'>‚Ä¢Import</span></code>. <code><span class='Value'>ùï©</span></code> describes the specific function requested from this file and its type signature, and the result is a BQN function that calls it. While a major purpose of <code><span class='Function'>‚Ä¢FFI</span></code> is to be called with files like libpng.so that you may already have on your system, we'll start by writing some C to make it clear what's happening on both sides of the interface. A factorial function is pretty short, so let's start there:</p>
<pre><span class='Comment'>#include &quot;stdint.h&quot;
</span>
<span class='Value'>int32_t</span> <span class='Value'>fac32</span><span class='Paren'>(</span><span class='Value'>int32_t</span> <span class='Value'>n</span><span class='Paren'>)</span> <span class='Brace'>{</span> <span class='Value'>return</span> <span class='Value'>n</span> <span class='Head'>?</span> <span class='Value'>n</span> <span class='Value'>*</span> <span class='Value'>fac32</span><span class='Paren'>(</span><span class='Value'>n</span> <span class='Function'>-</span> <span class='Number'>1</span><span class='Paren'>)</span> <span class='Head'>:</span> <span class='Number'>1</span><span class='Head'>;</span> <span class='Brace'>}</span>
</pre>
<p>To follow along on Linux, save as fac.c and compile with <code><span class='Value'>gcc</span> <span class='Value'>fac.c</span> <span class='Function'>-</span><span class='Value'>shared</span> <span class='Function'>-</span><span class='Value'>o</span> <span class='Value'>fac.so</span></code>. On other operating systems, do whatever does the same thing as that I guess. Then you can call it from BQN like this:</p>
<pre><span class='Value'>fac32</span> <span class='Gets'>‚Üê</span> <span class='String'>&quot;fac.so&quot;</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;i32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;fac32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;i32&quot;</span>
<span class='Function'>‚Ä¢Show</span> <span class='Function'>Fac32</span> <span class='Bracket'>‚ü®</span><span class='Number'>5</span><span class='Bracket'>‚ü©</span>  <span class='Comment'># 120
</span></pre>
<p>This assumes the BQN code is running in the same directory as fac.so. The use of <code><span class='Value'>fac32</span></code> on the first line and <code><span class='Function'>Fac32</span></code> on the second is <a href="expression.html#syntactic-role">syntactic role</a> manipulation: we have to treat the result of a function such as <code><span class='Function'>‚Ä¢FFI</span></code> as a subject when it's first created, but then we put it in a function role to call it (see also <a href="functional.html#functional-programming-in-bqn">functional programming</a>). Elements of <code><span class='Function'>‚Ä¢FFI</span></code>'s right argument follow the form of a C declaration: result type, function name, and then argument types. C functions can take any number of arguments, so for consistency <code><span class='Function'>Fac32</span></code> takes a list as its argument instead of taking a number directly. But using a <code><span class='Function'>Fac32</span><span class='Modifier2'>‚àò</span><span class='Function'>‚ãà</span></code> wrapper would be annoying and add a little overhead, so a special <code><span class='Function'>&gt;</span></code> declaration on the type indicates that the BQN argument should be used directly. Now our function has the same interface as <code><span class='Value'>‚Ä¢math.</span><span class='Function'>Fact</span></code>, making it easy to verify that it was pointless work:</p>
<pre><span class='Value'>fac32</span> <span class='Gets'>‚Üê</span> <span class='String'>&quot;fac.so&quot;</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;i32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;fac32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;i32&quot;</span>
<span class='Function'>!</span> <span class='Paren'>(</span><span class='Function'>Fac32</span> <span class='Function'>‚â°</span> <span class='Value'>‚Ä¢math.</span><span class='Function'>Fact</span><span class='Paren'>)</span> <span class='Number'>5</span>
</pre>
<p>And because the C function <code><span class='Value'>fac32</span></code> takes a signed integer but doesn't test for negative arguments, running <code><span class='Function'>Fac32</span> <span class='Number'>¬Ø1</span></code> shows some potential negative effects of a bad FFI call. When I compile with no optimization as shown above, it runs out of stack space and crashes BQN with a segmentation fault. With <code><span class='Function'>-O2</span></code> or higher, it takes several seconds to wrap around to positivies and eventually returns 0, but signed overflow is undefined behavior, so anything could happen really.</p>
<h3 id="using-pointers"><a class="header" href="#using-pointers">Using pointers</a></h3>
<p>For a more complicated example, here's a function that counts the number of cycles in a permutation, by tracing each cycle starting at its lowest index. In typical C fashion, it takes its argument as a length and then a pointer to the permutation indices, since a pointer by itself doesn't have any length information.</p>
<pre><span class='Comment'>#include &quot;stdint.h&quot;
</span>
<span class='Value'>uint32_t</span> <span class='Value'>cycles</span><span class='Paren'>(</span><span class='Value'>uint32_t</span> <span class='Value'>len</span><span class='Separator'>,</span> <span class='Value'>uint32_t*</span> <span class='Value'>p</span><span class='Paren'>)</span> <span class='Brace'>{</span>
    <span class='Value'>uint32_t</span> <span class='Value'>count</span> <span class='Function'>=</span> <span class='Number'>0</span><span class='Head'>;</span>
    <span class='Value'>for</span> <span class='Paren'>(</span><span class='Value'>uint32_t</span> <span class='Value'>i</span> <span class='Function'>=</span> <span class='Number'>0</span><span class='Head'>;</span> <span class='Value'>i</span> <span class='Function'>&lt;</span> <span class='Value'>len</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>++</span><span class='Paren'>)</span> <span class='Brace'>{</span>
        <span class='Value'>uint32_t</span> <span class='Value'>j</span> <span class='Function'>=</span> <span class='Value'>i</span><span class='Separator'>,</span> <span class='Value'>pj</span> <span class='Function'>=</span> <span class='Value'>p</span><span class='Bracket'>[</span><span class='Value'>j</span><span class='Bracket'>]</span><span class='Head'>;</span>
        <span class='Value'>count</span> <span class='Function'>+=</span> <span class='Value'>pj</span> <span class='Function'>&gt;=</span> <span class='Value'>i</span><span class='Head'>;</span>
        <span class='Value'>while</span> <span class='Paren'>(</span><span class='Value'>pj</span> <span class='Function'>&gt;</span> <span class='Value'>i</span><span class='Paren'>)</span> <span class='Brace'>{</span>
            <span class='Value'>p</span><span class='Bracket'>[</span><span class='Value'>j</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='Value'>i</span><span class='Head'>;</span>  <span class='Function'>//</span><span class='Comment'># Danger! Read on...
</span>            <span class='Value'>j</span> <span class='Function'>=</span> <span class='Value'>pj</span><span class='Head'>;</span>
            <span class='Value'>pj</span> <span class='Function'>=</span> <span class='Value'>p</span><span class='Bracket'>[</span><span class='Value'>j</span><span class='Bracket'>]</span><span class='Head'>;</span>
        <span class='Brace'>}</span>
    <span class='Brace'>}</span>
    <span class='Value'>return</span> <span class='Value'>count</span><span class='Head'>;</span>
<span class='Brace'>}</span>
</pre>
<p>With that compiled to <code><span class='Value'>cyc.so</span></code>, we can call it using the following BQN code. The pointer type is represented with the asterisk at the beginning rather than at the end, so that reading from left to right reveals the outermost structure first.</p>
<pre><span class='Value'>cycC</span> <span class='Gets'>‚Üê</span> <span class='String'>&quot;cyc.so&quot;</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;u32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;cycles&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;*u32&quot;</span>
<span class='Function'>‚Ä¢Show</span> <span class='Value'>p</span> <span class='Gets'>‚Üê</span> <span class='Function'>‚çã</span><span class='String'>&quot;cycle&quot;</span>  <span class='Comment'># ‚ü® 0 2 4 3 1 ‚ü©
</span><span class='Function'>‚Ä¢Show</span> <span class='Function'>CycC</span> <span class='Function'>‚â†</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚ãà</span> <span class='Value'>p</span>    <span class='Comment'># 3
</span><span class='Function'>‚Ä¢Show</span> <span class='Value'>p</span>             <span class='Comment'># ‚ü® 0 2 4 3 1 ‚ü©
</span></pre>
<p>The cycles are 0, 124, and 3, so that checks out. But <code><span class='Value'>cycles</span></code> modifies its argument <code><span class='Value'>p</span></code>, with the line <code><span class='Value'>p</span><span class='Bracket'>[</span><span class='Value'>j</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='Value'>i</span></code>. Is the BQN list <code><span class='Value'>p</span></code> changed when this happens? The check on the last line says no. But this isn't the rule! CBQN assumes the C function won't modify a <code><span class='Value'>*</span></code>-typed argument, and makes no guarantees about what happens if it does. What happens in this case is that <code><span class='Value'>p</span></code> is stored using 8 bits per element, so to widen it to 32 bits it's copied to temporary memory. If <code><span class='Value'>p</span></code> had 32-bit elements, then it would be modified, violating the basic assumption that BQN arrays are immutable. Identical arrays are often stored as references based on immutability, but they'd all change with the mutation, causing behavior that's impossible in normal BQN and tricky to debug!</p>
<p>So how does the FFI deal with mutation‚Äîbesides making this call well-defined, what if we want to see the modifications? Many C functions use pointer modification as a way to return multiple values. With <code><span class='Value'>&amp;</span></code> instead of <code><span class='Value'>*</span></code>, the original argument is always copied to avoid changes to aliased values, and after calling the function, that copy is returned as an extra result‚Äîso to match <code><span class='Function'>CycC</span></code> above, you'd have to throw in a <code><span class='Function'>‚äë</span></code> to discard it.</p>
<pre><span class='Value'>cycles</span> <span class='Gets'>‚Üê</span> <span class='String'>&quot;cyc.so&quot;</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;u32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;cycles&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&amp;u32&quot;</span>
<span class='Function'>‚Ä¢Show</span> <span class='Function'>Cycles</span> <span class='Function'>‚â†</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚ãà</span> <span class='Function'>‚çã</span><span class='String'>&quot;cycle&quot;</span>  <span class='Comment'># ‚ü® 3 ‚ü® 0 1 1 3 1 ‚ü© ‚ü©
</span></pre>
<p>In some cases you may only want to get this mutated value back. You can ignore the C result (relying on <code><span class='Value'>u32</span></code> not being stack-allocated!) by using <code><span class='String'>&quot;&quot;</span></code> for the result type, but then you get a 1-element list, for consistency with the case with multiple <code><span class='Value'>&amp;</span></code> arguments. Similar to <code><span class='Function'>&gt;</span></code> on a single argument, you can use <code><span class='String'>&quot;&amp;&quot;</span></code> for the result to get a single mutated argument returned directly.</p>
<pre><span class='Value'>cycI</span> <span class='Gets'>‚Üê</span> <span class='String'>&quot;cyc.so&quot;</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;&amp;&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;cycles&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&amp;u32&quot;</span>
<span class='Function'>‚Ä¢Show</span> <span class='Function'>CycI</span> <span class='Function'>‚â†</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚ãà</span> <span class='Function'>‚çã</span><span class='String'>&quot;cycle&quot;</span>  <span class='Comment'># ‚ü® 0 1 1 3 1 ‚ü©
</span></pre>
<p>(And now <code><span class='Function'>‚äî‚äê</span></code> gives a list of lists indicating which indices form each cycle, although that's not the same as a cycle decomposition, which would also indicate their ordering within the cycle.)</p>
<h2 id="type-specification"><a class="header" href="#type-specification">Type specification</a></h2>
<p>So the format of <code><span class='Value'>ùï©</span></code> is result type, function name, argument types. And the function name isn't complicated, it's just a string. Types have more rules. Here's the quick rundown:</p>
<ul>
<li>Numeric types are formatted like <code><span class='Value'>i32</span></code>, with <code><span class='Value'>i</span></code>, <code><span class='Value'>u</span></code>, or <code><span class='Value'>f</span></code>.</li>
<li>Another basic type, <code><span class='Value'>a</span></code>, exposes BQN values directly.</li>
<li>Typed pointers are written <code><span class='Value'>*t</span></code> or <code><span class='Value'>&amp;t</span></code>, and untyped pointers as <code><span class='Value'>*</span></code> or <code><span class='Value'>&amp;</span></code>.</li>
<li>Fixed-size arrays are written like <code><span class='Bracket'>[</span><span class='Number'>25</span><span class='Bracket'>]</span><span class='Value'>t</span></code>.</li>
<li>Structs are written like <code><span class='Brace'>{</span><span class='Value'>r</span><span class='Separator'>,</span><span class='Value'>s</span><span class='Separator'>,</span><span class='Value'>t</span><span class='Brace'>}</span></code>.</li>
<li>A <code><span class='Head'>:</span></code> suffix like <code><span class='Head'>:</span><span class='Value'>c16</span></code> indicates a corresponding BQN type.</li>
</ul>
<p>The numeric qualities are <code><span class='Value'>i</span></code> for signed integer, <code><span class='Value'>u</span></code> for unsigned integer, and <code><span class='Value'>f</span></code> for floating-point number. CBQN supports integer widths from 8 to 64, and float widths 32 and 64. <code><span class='Value'>u8</span></code> can be used for <code><span class='Value'>bool</span></code>.</p>
<p>Other than <code><span class='Value'>a</span></code>, which is implementation-dependent, all of these types have a direct correspondence to C. For example, <code><span class='Brace'>{</span><span class='Bracket'>[</span><span class='Number'>2</span><span class='Bracket'>]</span><span class='Value'>f32</span><span class='Separator'>,</span><span class='Value'>**i8</span><span class='Brace'>}</span></code> is a struct whose two fields are a list of two 32-bit floats and a pointer to pointers to 8-bit integers.</p>
<p>Shared libraries don't include type signatures, so <code><span class='Function'>‚Ä¢FFI</span></code> can't verify that the type signature for a given function is correct: it just passes the arguments however it should for that type signature. One consequence is that an imprecise type signature may still work. Pointers are all passed the same way, so their element types don't matter on the C side of the FFI; it's fine to use whatever's most convenient on the BQN side.</p>
<h3 id="type-conversions"><a class="header" href="#type-conversions">Type conversions</a></h3>
<p>So what do all these C types mean in BQN? The FFI tries to define sensible conversions. But BQN can't always represent every value directly, so it also provides <a href="#explicit-type-conversion">explicit conversions</a> with <code><span class='Head'>:</span></code> using the underlying bit representation, giving a way to safely store any value.</p>
<p>On to implicit conversions, let's start with <strong>numbers</strong>. CBQN numbers are 64-bit floats, which are a superset of integer types up to 32 bits, and 32-bit floats. So conversions from all these types are exact with no problems. Converting to a smaller integer type requires the float value to fit in that type, while converting to a smaller float type rounds.</p>
<p>Issues show up with <strong>64-bit integer</strong> types because 64-bit floats only have full integer precision from <code><span class='Function'>-</span><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>53</span></code> to <code><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>53</span></code>. <em>Some</em> integers beyond this range are representable, but others aren't: for example <code><span class='Number'>1</span><span class='Function'>+</span><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>53</span></code> rounds to <code><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>53</span></code>. For this reason numbers with absolute value <code><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>53</span></code> and greater error when converting between float and integer. Bare <code><span class='Value'>u64</span></code> and <code><span class='Value'>i64</span></code> types are fine when working with lengths and other things that can't reasonably be that large, but when all the bits are used they should be converted with <code><span class='Value'>u64</span><span class='Head'>:</span><span class='Value'>i32</span></code> or similar.</p>
<p>An <strong>array</strong> or <strong>struct</strong> corresponds to a BQN list, easy enough.</p>
<p>A BQN list or pointer object can be converted to a <strong>pointer</strong>, and a C pointer is always converted to a pointer object‚Äîit can't be converted to a list because the length is unknown, but sometimes a mutable pointer is a convenient way to get a list from a C function. <a href="#pointer-objects">Pointer objects</a> are BQN values designed specifically to encapsulate C pointers. If passed as an argument, its type needs to be compatible with the type for that argument, if it has one.</p>
<p>When an argument has an untyped pointer type <code><span class='Value'>*</span></code> or <code><span class='Value'>&amp;</span></code>, it can't take a list as input (what would the elements be converted to?) but any pointer object will be accepted. Since an untyped pointer isn't a list of anything, it's treated more like a scalar value. In particular a type like <code><span class='Value'>*</span><span class='Head'>:</span><span class='Value'>i32</span></code> converts a pointer back and forth from two integers.</p>
<h3 id="explicit-type-conversion"><a class="header" href="#explicit-type-conversion">Explicit type conversion</a></h3>
<p>Either the type as a whole, or any member of a struct, can have a conversion specification like <code><span class='Head'>:</span><span class='Value'>i32</span></code> at the end. The type after the colon uses the same format as C numeric types, with the quality <code><span class='Value'>c</span></code> allowed for characters in addition to <code><span class='Value'>i</span></code>, <code><span class='Value'>u</span></code>, and <code><span class='Value'>f</span></code>. Here CBQN supports the types it uses internally for arrays: <code><span class='Value'>u1</span></code> for booleans, <code><span class='Value'>i8</span></code> to <code><span class='Value'>i32</span></code> and <code><span class='Value'>c8</span></code> to <code><span class='Value'>c32</span></code>, and <code><span class='Value'>f64</span></code>.</p>
<p>With explicit conversion, each C value corresponds to a list of BQN values with the same bit representation. For example, you might use <code><span class='Value'>u64</span><span class='Head'>:</span><span class='Value'>u1</span></code> to represent a 64-bit number as 64 bits (little-endian or least significant first), or <code><span class='Value'>u64</span><span class='Head'>:</span><span class='Value'>c8</span></code> to represent it as 8 characters. Similarly, a pointer can be turned into plain bits and back with <code><span class='Value'>*</span><span class='Head'>:</span><span class='Value'>u1</span></code>. The <code><span class='Head'>:</span></code> also applies to compound values; another case is an argument such as <code><span class='Value'>*i64</span><span class='Head'>:</span><span class='Value'>i32</span></code>, which will be cast from a BQN list of 32-bit ints to a C list of 64-bit ints that's half as long (with an error if the length wasn't even). <code><span class='Value'>**</span><span class='Head'>:</span><span class='Value'>i32</span></code> works similarly, assuming 64-bit pointers. The initial <code><span class='Value'>*</span></code> can be replaced with <code><span class='Value'>&amp;</span></code> to get mutated values out, converting back to i32 on the way. Other compound cases have some complications and aren't supported in CBQN currently.</p>
<h2 id="argument-and-result-formats"><a class="header" href="#argument-and-result-formats">Argument and result formats</a></h2>
<p>This section covers how FFI arguments and results are structured in BQN, and collects the ways to tweak it.</p>
<p>The normal case is that <code><span class='Value'>ùï©</span></code> is a list of the arguments. You can pass in <code><span class='Value'>ùï®</span></code> if you really want, but is has to be an empty list. No arguments have been specified as coming from <code><span class='Value'>ùï®</span></code>! You can control where a C argument comes from by sticking <code><span class='Value'>ùï®</span></code> or <code><span class='Value'>ùï©</span></code> to the front (<code><span class='Value'>ùï©</span></code> does nothing, it's already the default). So for example, arguments of <code><span class='String'>&quot;i32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;ùï®i32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;ùï©i32&quot;</span></code> mean the function has to be called like <code><span class='Bracket'>‚ü®</span><span class='Number'>2</span><span class='Bracket'>‚ü©</span> <span class='Function'>Fn</span> <span class='Number'>1</span><span class='Ligature'>‚Äø</span><span class='Number'>3</span></code>. Then if a C argument is the only one included in its BQN argument, it can have a <code><span class='Function'>&gt;</span></code> at the beginning (either before or after the <code><span class='Value'>ùï®</span></code>/<code><span class='Value'>ùï©</span></code>) meaning that the BQN argument should be that value directly instead of the 1-element list.</p>
<p>If there are no mutable arguments, the result is what it is. Unless it isn't: a void result type <code><span class='String'>&quot;&quot;</span></code> results in a result value of <code><span class='String'>@</span></code>.</p>
<p>Mutable arguments (those with <code><span class='Value'>&amp;</span></code>) all have to be returned as part of the result. If there are any of these, the result is a list consisting of the C result followed by each mutable argument, mutatis mutandis, in the order they appeared in the arguments. Again, a result type of <code><span class='String'>&quot;&quot;</span></code> assumes a void result and leaves it out, so that the result just includes mutable values. A void result can also be written <code><span class='String'>&quot;&amp;&quot;</span></code> if there's exactly one such value, which means it won't be returned as a list.</p>
<p>In the table of examples below, <code><span class='Number'>5</span></code>, <code><span class='Number'>1</span></code>, <code><span class='Number'>0.5</span></code>, and <code><span class='Number'>3</span></code> are used as values for <code><span class='Value'>i8</span></code>, <code><span class='Value'>u1</span></code>, <code><span class='Value'>f64</span></code>, and <code><span class='Value'>i64</span></code> respectively, and <code><span class='Value'>a</span></code> and <code><span class='Value'>b</span></code> are possible list arguments with <code><span class='Value'>am</span></code> and <code><span class='Value'>bm</span></code> indicating modified versions of these.</p>
<table>
<thead>
<tr>
<th>Res</th>
<th>Args</th>
<th>Call</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span class='String'>&quot;i64&quot;</span></code></td>
<td><code><span class='String'>&quot;i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;f64&quot;</span></code></td>
<td><code><span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Number'>5</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Separator'>,</span><span class='Number'>0.5</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='Number'>3</span></code></td>
</tr>
<tr>
<td><code><span class='String'>&quot;i64&quot;</span></code></td>
<td><code><span class='String'>&quot;ùï®i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;ùï®u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;f64&quot;</span></code></td>
<td><code><span class='Bracket'>‚ü®</span><span class='Number'>5</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Bracket'>‚ü©</span> <span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Number'>0.5</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='Number'>3</span></code></td>
</tr>
<tr>
<td><code><span class='String'>&quot;&quot;</span></code></td>
<td><code><span class='String'>&quot;i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;ùï®f64&quot;</span></code></td>
<td><code><span class='Number'>0.5</span> <span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Number'>5</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='String'>@</span></code></td>
</tr>
<tr>
<td><code><span class='String'>&quot;i64&quot;</span></code></td>
<td><code><span class='String'>&quot;&amp;i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&amp;f64&quot;</span></code></td>
<td><code><span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Value'>a</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Separator'>,</span><span class='Value'>b</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='Bracket'>‚ü®</span><span class='Number'>3</span><span class='Separator'>,</span><span class='Value'>am</span><span class='Separator'>,</span><span class='Value'>bm</span><span class='Bracket'>‚ü©</span></code></td>
</tr>
<tr>
<td><code><span class='String'>&quot;&quot;</span></code></td>
<td><code><span class='String'>&quot;&amp;i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&amp;f64&quot;</span></code></td>
<td><code><span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Value'>a</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Separator'>,</span><span class='Value'>b</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='Bracket'>‚ü®</span><span class='Value'>am</span><span class='Separator'>,</span><span class='Value'>bm</span><span class='Bracket'>‚ü©</span></code></td>
</tr>
<tr>
<td><code><span class='String'>&quot;&amp;&quot;</span></code></td>
<td><code><span class='String'>&quot;&amp;i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;f64&quot;</span></code></td>
<td><code><span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Value'>a</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Separator'>,</span><span class='Number'>0.5</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='Value'>am</span></code></td>
</tr>
</tbody>
</table>
<h2 id="pointer-objects"><a class="header" href="#pointer-objects">Pointer objects</a></h2>
<p>Some C functions might allocate or map memory and return a pointer to it, or take a pointer and return a related pointer. A pointer type like <code><span class='Value'>*</span><span class='Head'>:</span><span class='Value'>i32</span></code> doesn't have a meaningful representation in BQN but allows for passing pointers around between C functions. But often it's useful to be able to manipulate pointers within BQN, so the FFI can create and accept pointer objects that support the relevant operations.</p>
<p>In <code><span class='Function'>‚Ä¢FFI</span></code>, any pointer result type without an explicit conversion (<code><span class='Value'>*</span></code>, <code><span class='Value'>*u32</span></code>, <code><span class='Value'>*</span><span class='Brace'>{</span><span class='Value'>u8</span><span class='Separator'>,</span><span class='Value'>**f32</span><span class='Brace'>}</span></code> but not <code><span class='Value'>*</span><span class='Head'>:</span><span class='Value'>i8</span></code>) means the return value is a pointer object. The pointer object remembers what type it has, but can also be cast to other types. It can be passed as an argument to a field with the same type, or a compatible type‚Äîit's allowed to use an untyped pointer <code><span class='Value'>*</span></code> somewhere that a typed pointer appears, or vice-versa. For example <code><span class='Value'>*</span><span class='Brace'>{</span><span class='Value'>*f64</span><span class='Separator'>,</span><span class='Value'>*</span><span class='Brace'>}</span></code> is compatible with <code><span class='Value'>*</span><span class='Brace'>{</span><span class='Value'>*</span><span class='Separator'>,</span><span class='Value'>*u8</span><span class='Brace'>}</span></code>.</p>
<p>The plain <code><span class='Value'>*</span></code> type gives an untyped pointer. The only things that can be done with it are to pass it back in to the FFI, and cast it to a different pointer type. Other pointers support more operations, and they actually have two defining properties: the element type, and a stride, which is a distance in bytes. In pointers returned by the FFI, the stride is the element type's width; in others, it may be the width of some parent element type.</p>
<p>The functions for working with a pointer object are exposed as fields of that object. Here's a summary of these functions. Other than <code><span class='Function'>Cast</span></code>, they all give errors if the pointer is untyped.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span class='Function'>Read</span></code></td>
<td>Read value at offset <code><span class='Value'>ùï©</span></code></td>
</tr>
<tr>
<td><code><span class='Function'>Write</span></code></td>
<td>Write value <code><span class='Value'>ùï©</span></code> at offset <code><span class='Value'>ùï®</span><span class='Function'>‚ä£</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td><code><span class='Function'>Add</span></code></td>
<td>Return a new pointer offset by <code><span class='Value'>ùï©</span></code></td>
</tr>
<tr>
<td><code><span class='Function'>Sub</span></code></td>
<td>Offset by <code><span class='Function'>-</span><span class='Value'>ùï©</span></code>, or return the offset from <code><span class='Value'>ùï©</span></code> to this pointer</td>
</tr>
<tr>
<td><code><span class='Function'>Cast</span></code></td>
<td>Return a new pointer to the same location with type <code><span class='Value'>ùï©</span></code></td>
</tr>
<tr>
<td><code><span class='Function'>Field</span></code></td>
<td>Return a new pointer to field number <code><span class='Value'>ùï©</span></code>, maintaining stride</td>
</tr>
</tbody>
</table>
<h3 id="pointer-access-and-arithmetic"><a class="header" href="#pointer-access-and-arithmetic">Pointer access and arithmetic</a></h3>
<p>In CBQN, <code><span class='String'>@</span></code> as a &quot;path&quot; for <code><span class='Function'>‚Ä¢FFI</span></code> exposes libc functions including <code><span class='Value'>malloc</span></code>, which gives us an easy way to make a pointer to play around with. <code><span class='Function'>Read</span></code> and <code><span class='Function'>Write</span></code> work like you probably expect.</p>
<pre><span class='Value'>malloc_i32</span> <span class='Gets'>‚Üê</span> <span class='String'>@</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;*i32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;malloc&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;u64&quot;</span>
<span class='Value'>ptr</span> <span class='Gets'>‚Üê</span> <span class='Function'>Malloc_i32</span> <span class='Number'>4</span><span class='Function'>√ó</span><span class='Number'>10</span>  <span class='Comment'># Space for 10 ints
</span><span class='Function'>‚Ä¢Show</span> <span class='Value'>ptr.</span><span class='Function'>Read</span> <span class='Number'>3</span>   <span class='Comment'># Uninitialized
</span><span class='Number'>3</span> <span class='Value'>ptr.</span><span class='Function'>Write</span> <span class='Number'>123</span>
<span class='Function'>‚Ä¢Show</span> <span class='Value'>ptr.</span><span class='Function'>Read</span> <span class='Number'>3</span>   <span class='Comment'># Now 123
</span></pre>
<p>You can use arithmetic to make another pointer with an offset, or find the offset between two pointers. Pointer objects are immutable in the sense that a given pointer object always points to the same location (the underlying state of the memory can of course change, that's the whole point).</p>
<pre><span class='Value'>off</span> <span class='Gets'>‚Üê</span> <span class='Value'>ptr.</span><span class='Function'>Add</span> <span class='Number'>3</span>
<span class='Function'>‚Ä¢Show</span> <span class='Value'>off.</span><span class='Function'>Sub</span> <span class='Value'>ptr</span>  <span class='Comment'># 3
</span><span class='Function'>‚Ä¢Show</span> <span class='Value'>off.</span><span class='Function'>Read</span> <span class='Number'>0</span>   <span class='Comment'># 123
</span></pre>
<p>And we can free it, showing how passing a pointer back in to the FFI works:</p>
<pre><span class='Value'>free</span> <span class='Gets'>‚Üê</span> <span class='String'>@</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;free&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;*&quot;</span>
<span class='Function'>Free</span> <span class='Value'>ptr</span>
</pre>
<p>Now malloc's memory manager has freed the allocated space, but <code><span class='Function'>‚Ä¢FFI</span></code> can't know that &quot;free&quot; does this, and doesn't do anything to the pointer object (it also couldn't track down other pointers like <code><span class='Value'>off</span></code> that still point into the same space). So now <code><span class='Function'>‚Ä¢Show</span> <span class='Value'>ptr.</span><span class='Function'>Read</span> <span class='Number'>3</span></code> may still run without error, but it's use-after-free and could do anything. Using pointer objects is low-level programming; treat it like assembly.</p>
<h3 id="compound-pointers"><a class="header" href="#compound-pointers">Compound pointers</a></h3>
<p>Now for some more sophisticated pointer stuff. Let's start with a hundred bytes of memory:</p>
<pre><span class='Value'>malloc</span> <span class='Gets'>‚Üê</span> <span class='String'>@</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;*&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;malloc&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;u64&quot;</span>
<span class='Value'>pv</span> <span class='Gets'>‚Üê</span> <span class='Function'>Malloc</span> <span class='Number'>100</span>
</pre>
<p>Since <code><span class='Value'>pv</span></code> is untyped, <code><span class='Value'>pv.</span><span class='Function'>Read</span> <span class='Number'>0</span></code>, <code><span class='Value'>pv.</span><span class='Function'>Add</span> <span class='Number'>1</span></code> and so on all give errors. All we can do is cast it:</p>
<pre><span class='Value'>ps</span> <span class='Gets'>‚Üê</span> <span class='Value'>pv.</span><span class='Function'>Cast</span> <span class='String'>&quot;{[2]i8,i16}&quot;</span>
</pre>
<p>It works! And now if we read from it, we'll get‚Ä¶ well, generally a bunch of zeros, but the memory's uninitialized so you never know. We'll initialize to something known by placing the value <code><span class='Value'>i</span></code> in byte index <code><span class='Value'>i</span></code>. A normal way to do this is <code><span class='Paren'>(</span><span class='Value'>pv.</span><span class='Function'>Cast</span> <span class='String'>&quot;u8&quot;</span><span class='Paren'>)</span><span class='Value'>.</span><span class='Function'>Write</span><span class='Modifier'>Àú¬®</span> <span class='Function'>‚Üï</span><span class='Number'>100</span></code>, but just to show what's possible:</p>
<pre><span class='Paren'>(</span><span class='Value'>pv.</span><span class='Function'>Cast</span> <span class='String'>&quot;[100]u8&quot;</span><span class='Paren'>)</span><span class='Value'>.</span><span class='Function'>Write</span> <span class='Function'>‚Üï</span><span class='Number'>100</span>
</pre>
<p>The argument <code><span class='Function'>‚Üï</span><span class='Number'>100</span></code> is matched to the element type <code><span class='Bracket'>[</span><span class='Number'>100</span><span class='Bracket'>]</span><span class='Value'>u8</span></code> in the same way that it would be in an <code><span class='Function'>‚Ä¢FFI</span></code> call with argument type <code><span class='Bracket'>[</span><span class='Number'>100</span><span class='Bracket'>]</span><span class='Value'>u8</span></code>. Now we can read off some values:</p>
<pre><span class='Function'>‚Ä¢Show</span> <span class='Value'>ps.</span><span class='Function'>Read</span> <span class='Number'>0</span>            <span class='Comment'># ‚ü® ‚ü® 0 1 ‚ü© 770 ‚ü©
</span><span class='Function'>‚Ä¢Show</span> <span class='Paren'>(</span><span class='Value'>ps.</span><span class='Function'>Field</span> <span class='Number'>0</span><span class='Paren'>)</span><span class='Value'>.</span><span class='Function'>Read</span> <span class='Number'>3</span>  <span class='Comment'># ‚ü® 12 13 ‚ü©
</span></pre>
<p><code><span class='Number'>770</span></code> is <code><span class='Number'>2</span><span class='Function'>+</span><span class='Number'>3</span><span class='Function'>√ó</span><span class='Number'>256</span></code>; note the little-endian order. As for the <code><span class='Function'>Field</span></code> example, <code><span class='Value'>ps.</span><span class='Function'>Field</span> <span class='Number'>0</span></code> picks out the <code><span class='Bracket'>[</span><span class='Number'>2</span><span class='Bracket'>]</span><span class='Value'>i8</span></code> component, since it's the first field of the struct type <code><span class='Brace'>{</span><span class='Bracket'>[</span><span class='Number'>2</span><span class='Bracket'>]</span><span class='Value'>i8</span><span class='Separator'>,</span><span class='Value'>i16</span><span class='Brace'>}</span></code>. However, reading at offset 3 doesn't just shift by 6 bytes, which would land in one of the <code><span class='Value'>i16</span></code> components. Because <code><span class='Function'>Field</span></code> preserves the original 4-byte stride of <code><span class='Value'>ps</span></code>, it shifts by 12 bytes, reading the <code><span class='Bracket'>[</span><span class='Number'>2</span><span class='Bracket'>]</span><span class='Value'>i8</span></code> field of the overall struct with index 3. Doing a <code><span class='Function'>Cast</span></code> instead would have discarded this stride.</p>
<pre><span class='Function'>‚Ä¢Show</span> <span class='Paren'>(</span><span class='Value'>ps.</span><span class='Function'>Cast</span> <span class='String'>&quot;[2]i8&quot;</span><span class='Paren'>)</span><span class='Value'>.</span><span class='Function'>Read</span> <span class='Number'>3</span>     <span class='Comment'># ‚ü® 6 7 ‚ü©
</span><span class='Function'>‚Ä¢Show</span> <span class='Paren'>((</span><span class='Value'>ps.</span><span class='Function'>Add</span> <span class='Number'>3</span><span class='Paren'>)</span><span class='Value'>.</span><span class='Function'>Field</span> <span class='Number'>0</span><span class='Paren'>)</span><span class='Value'>.</span><span class='Function'>Read</span> <span class='Number'>0</span>  <span class='Comment'># ‚ü® 12 13 ‚ü©
</span></pre>
<p>As a result of this design, you can pick out, say, the second <code><span class='Value'>i8</span></code> in each of the first five structs without any intermediate pointer arithmetic (the two <code><span class='Function'>Field</span></code> calls below are each only done once, then <code><span class='Function'>Read</span></code> is called 5 times).</p>
<pre><span class='Function'>‚Ä¢Show</span> <span class='Paren'>((</span><span class='Value'>ps.</span><span class='Function'>Field</span> <span class='Number'>0</span><span class='Paren'>)</span><span class='Value'>.</span><span class='Function'>Field</span> <span class='Number'>1</span><span class='Paren'>)</span><span class='Value'>.</span><span class='Function'>Read</span><span class='Modifier'>¬®</span> <span class='Function'>‚Üï</span><span class='Number'>5</span>  <span class='Comment'># ‚ü® 1 5 9 13 17 ‚ü©
</span></pre>
<p>Casting also makes it possible to offset a pointer by a specific number of bytes: cast to <code><span class='Value'>i8</span></code> or <code><span class='Value'>u8</span></code>, add an offset, and cast back to the original type.</p>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>Since strings present some encoding issues, and C has an unfortunate practice of using null-terminated strings everywhere, let's go over some details of how to work with these. To pass an ASCII string in, the appropriate type is <code><span class='Value'>*u8</span><span class='Head'>:</span><span class='Value'>c8</span></code>, which as an <a href="#explicit-type-conversion">explicit conversion</a> takes a list of 1-byte characters, and passes it as a list of 1-byte integers (sometimes C <code><span class='Value'>char</span></code>s are signed ints, but the FFI just passes bits around so <code><span class='Value'>i8</span></code> and <code><span class='Value'>u8</span></code> behave the same way). Null-terminate the string explicitly in BQN by passing <code><span class='Value'>str</span><span class='Function'>‚àæ</span><span class='String'>@</span></code> where <code><span class='Value'>str</span></code> is the string itself.</p>
<p>This format is also suitable for sequences of not-necessarily-ASCII bytes like the output of <code><span class='Value'>‚Ä¢file.</span><span class='Function'>Bytes</span></code>. To pass unicode characters as UTF-8, you can use <code><span class='Function'>‚Ä¢ToUTF8</span> <span class='Value'>str</span></code> in CBQN, and there are also pure BQN conversion functions in bqn-libs <a href="https://github.com/mlochbaum/bqn-libs/blob/master/strings.bqn">strings.bqn</a>.</p>
<p>When a C function passes you back a string, you get a pointer, and to get a BQN list of characters you're going to have to hunt down that null byte. <code><span class='Value'>*u8</span><span class='Head'>:</span><span class='Value'>c8</span></code> is allowed for the result type, but it gives a pointer with element type <code><span class='Value'>u8</span><span class='Head'>:</span><span class='Value'>c8</span></code>, which means <code><span class='Function'>Read</span></code> always returns a 1-character list instead of a single character. Let's use <code><span class='Value'>*u8</span></code> instead. We could build the string during the search to read each character only once, but it's simpler and faster to use two passes:</p>
<pre><span class='Function'>StrFromPtr</span> <span class='Gets'>‚Üê</span> <span class='Brace'>{</span> <span class='String'>@</span> <span class='Function'>+</span> <span class='Value'>ùï©.</span><span class='Function'>Read</span><span class='Modifier'>¬®</span> <span class='Function'>‚Üï</span> <span class='Number'>1</span><span class='Modifier2'>‚ä∏</span><span class='Function'>+</span><span class='Modifier2'>‚Ä¢_while_</span><span class='Paren'>(</span><span class='Number'>0</span><span class='Function'>‚â†</span><span class='Value'>ùï©.</span><span class='Function'>Read</span><span class='Paren'>)</span> <span class='Number'>0</span> <span class='Brace'>}</span>
</pre>
<p>Using CBQN's <code><span class='String'>@</span></code> argument to get <code><span class='Value'>strlen</span></code> is much faster at the cost of a bit of implementation dependence. In either version you might want to apply <code><span class='Function'>‚Ä¢FromUTF8</span></code> afterwards if the string is UTF-8 encoded and not just a bunch of bytes.</p>
<pre><span class='Function'>StrFromPtr</span> <span class='Gets'>‚Üê</span> <span class='Paren'>(</span><span class='String'>@</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;u64&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;strlen&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;*u8&quot;</span><span class='Paren'>)</span><span class='Brace'>{</span> <span class='String'>@</span> <span class='Function'>+</span> <span class='Value'>ùï©.</span><span class='Function'>Read</span><span class='Modifier'>¬®</span> <span class='Function'>‚ÜïùîΩ</span><span class='Value'>ùï©</span> <span class='Brace'>}</span>
</pre>
<p>And the fastest way is to hook into CBQN's internal function for building a string instead of using the pointer object interface at all. There's also the option of using <code><span class='Value'>bqn_makeUTF8Str</span></code> instead of <code><span class='Value'>bqn_makeC8Vec</span></code> to get UTF-8 conversion included.</p>
<pre><span class='Value'>strlen</span> <span class='Gets'>‚Üê</span> <span class='String'>@</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;u64&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;strlen&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;*u8&quot;</span>
<span class='Value'>mkstr</span>  <span class='Gets'>‚Üê</span> <span class='String'>@</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;a&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;bqn_makeC8Vec&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;ùï®u64&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;*u8&quot;</span>
<span class='Function'>StrFromPtr</span> <span class='Gets'>‚Üê</span> <span class='Function'>Strlen</span><span class='Modifier2'>‚ä∏</span><span class='Function'>MkStr</span>
</pre>
